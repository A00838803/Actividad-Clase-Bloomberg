# -*- coding: utf-8 -*-
"""Actividad Clase Bloomberg - 3 Min 1 Dia

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V9-qmUJrVdAH7VgGmfRz0EUOKLDd3muu
"""

# Import required libraries
import pandas as pd
import numpy as np
from google.colab import files
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller, kpss
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.vector_ar.vecm import coint_johansen
import matplotlib.pyplot as plt

# Upload Excel files
print("Please upload KO-3Min Excel file")
ko_upload = files.upload()
ko_filename = list(ko_upload.keys())[0]
ko_df = pd.read_excel(ko_filename)

print("Please upload MSFT-3Min Excel file")
msft_upload = files.upload()
msft_filename = list(msft_upload.keys())[0]
msft_df = pd.read_excel(msft_filename)

print("Please upload AMZN-3Min Excel file")
amzn_upload = files.upload()
amzn_filename = list(amzn_upload.keys())[0]
amzn_df = pd.read_excel(amzn_filename)

# Print available columns
print("\nKO DataFrame columns:", list(ko_df.columns))
print("MSFT DataFrame columns:", list(msft_df.columns))
print("AMZN DataFrame columns:", list(amzn_df.columns))

# Ask user for the correct column name
close_column = input("Please enter the column name containing closing prices: ")

# Extract closing prices using user-specified column name
try:
    ko_close = ko_df[close_column]
    msft_close = msft_df[close_column]
    amzn_close = amzn_df[close_column]
except KeyError:
    print(f"Error: Column '{close_column}' not found in one or more DataFrames")
    print("Please check the column names and try again")
    raise

# Ensure all series have the same length
min_length = min(len(ko_close), len(msft_close), len(amzn_close))
ko_close = ko_close[:min_length]
msft_close = msft_close[:min_length]
amzn_close = amzn_close[:min_length]

# Function to clean series (handle NaN and inf)
def clean_series(series, name):
    print(f"\nChecking {name} for NaN or inf values:")
    nan_count = series.isna().sum()
    inf_count = np.isinf(series).sum()
    print(f"  - NaN count: {nan_count}")
    print(f"  - Inf count: {inf_count}")

    # Drop NaN and inf values
    cleaned_series = series.replace([np.inf, -np.inf], np.nan).dropna()

    print(f"  - Length after cleaning: {len(cleaned_series)}")
    return cleaned_series

# Clean the series
ko_close = clean_series(ko_close, "KO")
msft_close = clean_series(msft_close, "MSFT")
amzn_close = clean_series(amzn_close, "AMZN")

# Re-align series to the same length after cleaning
min_length = min(len(ko_close), len(msft_close), len(amzn_close))
ko_close = ko_close[:min_length]
msft_close = msft_close[:min_length]
amzn_close = amzn_close[:min_length]

# Function for unit root tests with interpretation
def unit_root_tests(series, name):
    print(f"\nUnit Root Tests for {name}:")

    # ADF Test
    try:
        adf_result = adfuller(series)
        print("ADF Test:")
        print(f'ADF Statistic: {adf_result[0]:.4f}')
        print(f'p-value: {adf_result[1]:.4f}')
        print(f'Critical Values: {adf_result[4]}')
        print("Interpretation:")
        if adf_result[1] < 0.05:
            print(f"  - p-value < 0.05: Reject null hypothesis - {name} is stationary")
        else:
            print(f"  - p-value >= 0.05: Fail to reject null - {name} may be non-stationary")
    except ValueError as e:
        print(f"ADF Test failed for {name}: {e}")

    # KPSS Test
    try:
        kpss_result = kpss(series)
        print("\nKPSS Test:")
        print(f'KPSS Statistic: {kpss_result[0]:.4f}')
        print(f'p-value: {kpss_result[1]:.4f}')
        print(f'Critical Values: {kpss_result[3]}')
        print("Interpretation:")
        if kpss_result[1] < 0.05:
            print(f"  - p-value < 0.05: Reject null hypothesis - {name} is non-stationary")
        else:
            print(f"  - p-value >= 0.05: Fail to reject null - {name} may be stationary")
    except ValueError as e:
        print(f"KPSS Test failed for {name}: {e}")

# Perform unit root tests
unit_root_tests(ko_close, "KO")
unit_root_tests(msft_close, "MSFT")
unit_root_tests(amzn_close, "AMZN")

# Difference the series if non-stationary
ko_diff = ko_close.diff().dropna()
msft_diff = msft_close.diff().dropna()
amzn_diff = amzn_close.diff().dropna()

# Function to find best ARMA model (using ARIMA with d=0)
def find_best_arma(series, name, max_p=3, max_q=3):
    best_aic = float('inf')
    best_order = None

    for p in range(max_p + 1):
        for q in range(max_q + 1):
            try:
                model = ARIMA(series, order=(p, 0, q))
                results = model.fit()
                if results.aic < best_aic:
                    best_aic = results.aic
                    best_order = (p, 0, q)
            except:
                continue

    print(f"\nBest ARMA model for {name}:")
    print(f"Order: {best_order}")
    print(f"AIC: {best_aic:.2f}")
    print("Interpretation:")
    print(f"  - p={best_order[0]}: {best_order[0]} autoregressive term(s)")
    print(f"  - q={best_order[2]}: {best_order[2]} moving average term(s)")
    return best_order

# Find and fit best ARMA models on differenced series
ko_order = find_best_arma(ko_diff, "KO")
msft_order = find_best_arma(msft_diff, "MSFT")
amzn_order = find_best_arma(amzn_diff, "AMZN")

# Fit final ARMA models
ko_model = ARIMA(ko_diff, order=ko_order).fit()
msft_model = ARIMA(msft_diff, order=msft_order).fit()
amzn_model = ARIMA(amzn_diff, order=amzn_order).fit()

# Cointegration test with interpretation
def cointegration_test(df):
    try:
        result = coint_johansen(df, det_order=0, k_ar_diff=1)
        print("\nJohansen Cointegration Test (KO, MSFT, AMZN):")
        print(f"Trace statistic: {result.lr1}")
        print(f"Critical values (90%, 95%, 99%): {result.cvt}")
        print("Interpretation:")
        for i in range(len(result.lr1)):
            if result.lr1[i] > result.cvt[i, 1]:
                print(f"  - r = {i}: Cointegration exists at 95% confidence level")
                print(f"    Trace statistic ({result.lr1[i]:.2f}) > 95% critical value ({result.cvt[i, 1]:.2f})")
            else:
                print(f"  - r = {i}: No cointegration at 95% confidence level")
                print(f"    Trace statistic ({result.lr1[i]:.2f}) <= 95% critical value ({result.cvt[i, 1]:.2f})")
        if result.lr1[0] > result.cvt[0, 1]:
            print("Conclusion: KO, MSFT, and AMZN are cointegrated - they share a long-run equilibrium relationship")
        else:
            print("Conclusion: No evidence of cointegration among KO, MSFT, and AMZN")
    except ValueError as e:
        print(f"Cointegration test failed: {e}")

# Prepare data for cointegration
coint_df = pd.DataFrame({
    'KO': ko_close,
    'MSFT': msft_close,
    'AMZN': amzn_close
}).dropna()
cointegration_test(coint_df)

# Forecast next 30 periods
forecast_steps = 30
ko_forecast = ko_model.forecast(steps=forecast_steps)
msft_forecast = msft_model.forecast(steps=forecast_steps)
amzn_forecast = amzn_model.forecast(steps=forecast_steps)

# Create forecast index
last_index = len(ko_close) - 1
forecast_index = range(last_index + 1, last_index + 1 + forecast_steps)

# Plot original series with forecasts
plt.figure(figsize=(12,6))
plt.plot(ko_close, label='KO Historical')
plt.plot(forecast_index, ko_forecast, label='KO Forecast', color='red')
plt.plot(msft_close, label='MSFT Historical')
plt.plot(forecast_index, msft_forecast, label='MSFT Forecast', color='green')
plt.plot(amzn_close, label='AMZN Historical')
plt.plot(forecast_index, amzn_forecast, label='AMZN Forecast', color='purple')
plt.title('KO, MSFT, and AMZN Closing Prices with Forecasts')
plt.legend()
plt.show()

# Detailed forecast plot with confidence intervals and interpretation
def plot_forecast(model, series, name, steps=30):
    try:
        forecast_obj = model.get_forecast(steps=steps)
        forecast = forecast_obj.predicted_mean
        conf_int = forecast_obj.conf_int()

        forecast_index = range(len(series), len(series) + steps)

        plt.figure(figsize=(12,6))
        plt.plot(series, label=f'{name} Historical')
        plt.plot(forecast_index, forecast, label='Forecast', color='red')
        plt.fill_between(forecast_index,
                        conf_int.iloc[:, 0],
                        conf_int.iloc[:, 1],
                        color='pink',
                        alpha=0.3,
                        label='95% Confidence Interval')
        plt.title(f'{name} Price Forecast')
        plt.legend()
        plt.show()

        # Forecast interpretation
        last_value = series.iloc[-1]
        mean_forecast = forecast.mean()
        print(f"\nForecast Interpretation for {name}:")
        print(f"Last observed value: {last_value:.2f}")
        print(f"Average forecast value: {mean_forecast:.2f}")
        print(f"Forecast change: {mean_forecast - last_value:.2f}")
        if mean_forecast > last_value:
            print("Trend: Upward forecast trend")
        elif mean_forecast < last_value:
            print("Trend: Downward forecast trend")
        else:
            print("Trend: Flat forecast trend")
        print(f"95% CI range at period {steps}: [{conf_int.iloc[-1, 0]:.2f}, {conf_int.iloc[-1, 1]:.2f}]")
    except ValueError as e:
        print(f"Forecast failed for {name}: {e}")

# Generate detailed forecast plots and interpretations
plot_forecast(ko_model, ko_diff, "KO")
plot_forecast(msft_model, msft_diff, "MSFT")
plot_forecast(amzn_model, amzn_diff, "AMZN")

# Print forecast values
print("\nKO Forecast Values (next 5 periods):")
print(ko_forecast[:5])
print("\nMSFT Forecast Values (next 5 periods):")
print(msft_forecast[:5])
print("\nAMZN Forecast Values (next 5 periods):")
print(amzn_forecast[:5])